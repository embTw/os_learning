# 遇到的问题及解决方法
## 打印出未知的字符
现象：打印程序没有问题，结果打印结果是一些奇怪的程序中根本没有出现过的字符，而且当代码位置调整后，打印的字符还会变化。

原因：在实地址模式下，内存的寻址是通过段寄存器提供的段基址+偏移地址得到的，然而当我们的程序被加载到内存`0x7c00`这个位置的时候，段寄存器并没有调整为`0x7c00`，仍然为0，所以我们访问的内存地址实际上是数据的偏移地址，真正的数据地址应该是`0x7c00+偏移地址`。

解决方法：在程序中加入代码
	```[org 0x7c00]```
这行代码可以让编译器为我们自动修正所有相对地址为正确的绝对地址

## 字符串换行
`HELLO_MESSAGE:
    db "hello, world!", 0dh, 0ah, 0`

0dh表示回车，0ah表示换行，两者组合完成换行的功能
## %include问题
`%include "print_string.asm"`

由于C语言的习惯，我把这句话放到了文件头，结果发现打印不出东西，把它放到文件中部再次尝试，成功打印。

查看反汇编代码

![img1](.\img\img1.png)


发现其实 `%include "print_string.asm"` 只不过是简单地将print_string.asm放到当前位置，显然如果把这句话放到文件开头，那么这个函数会被首先执行，然而此时根本没有调用者调用该函数，自然不可能打印出正确的字符串，最后执行到ret时出错，因为没有调用者，栈中根本没有返回的地址，那么自然无法返回。

同理，将字符串放到文件开头也是有问题，字符串会被当做代码执行。

